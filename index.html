<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>LLVMCFG by toshipiazza</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>LLVMCFG</h1>
        <p>LLVM Pass for dynamic CFG generation</p>

        <p class="view"><a href="https://github.com/toshipiazza/LLVMCFG">View the Project on GitHub <small>toshipiazza/LLVMCFG</small></a></p>


        <ul>
          <li><a href="https://github.com/toshipiazza/LLVMCFG/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/toshipiazza/LLVMCFG/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/toshipiazza/LLVMCFG">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h1>

<h6>
<a id="notice-this-project-is-wip" class="anchor" href="#notice-this-project-is-wip" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Notice, this project is WIP</h6>

<p>LLVMCFG is an llvm pass that modifies the code generation phase of the clang compiler. Given some source code, the generated code will keep track of all branches taken at runtime, and outputs a dynamically computed control flow graph. This project was inspired by the <code>cbr.c</code> and <code>cbrtrace.c</code> samples in the DynamoRIO code base which compute the control flow dynamically using dynamic binary instrumentation.</p>

<h1>
<a id="implementation" class="anchor" href="#implementation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Implementation</h1>

<p>In order to compute the dynamic control flow graph, we must specifically target conditional branch instructions:</p>

<div class="highlight highlight-source-assembly"><pre><span class="pl-c">; &lt;label&gt;1:</span>
<span class="pl-c">  ; ...</span>
<span class="pl-en">  br i1 %</span><span class="pl-c1">2</span><span class="pl-en"> %</span><span class="pl-c1">3</span><span class="pl-en"> %</span><span class="pl-c1">4</span>

<span class="pl-c">; &lt;label&gt;3:</span>
<span class="pl-c">  ; skip all phi nodes, etc</span>
<span class="pl-en">  </span><span class="pl-k">call</span><span class="pl-en"> void @__note_taken(i8</span><span class="pl-s1">*</span><span class="pl-en"> blockaddress(@main</span><span class="pl-s1">,</span><span class="pl-en"> %</span><span class="pl-c1">1</span><span class="pl-en">)</span><span class="pl-s1">,</span><span class="pl-en"> i8</span><span class="pl-s1">*</span><span class="pl-en"> blockaddress(@main</span><span class="pl-s1">,</span><span class="pl-en"> %</span><span class="pl-c1">3</span><span class="pl-en">))</span>
<span class="pl-c">  ; original fallthrough instrumentation</span>

<span class="pl-c">; &lt;label&gt;4:</span>
<span class="pl-c">  ; skip all phi nodes, etc</span>
<span class="pl-en">  </span><span class="pl-k">call</span><span class="pl-en"> void @__note_taken(i8</span><span class="pl-s1">*</span><span class="pl-en"> blockaddress(@main</span><span class="pl-s1">,</span><span class="pl-en"> %</span><span class="pl-c1">1</span><span class="pl-en">)</span><span class="pl-s1">,</span><span class="pl-en"> i8</span><span class="pl-s1">*</span><span class="pl-en"> blockaddress(@main</span><span class="pl-s1">,</span><span class="pl-en"> %</span><span class="pl-c1">4</span><span class="pl-en">))</span>
<span class="pl-c">  ; original target instrumentation</span></pre></div>

<p>Here, given a conditional branch instruction we find the fallthrough basic block and the taken basic block, and we add a call to <code>__note_taken()</code>, which keeps state. We use the <code>blockaddress()</code> mechanism for the general case to get the addresses of basic blocks.</p>

<p>Note that <code>blockaddress(entry)</code> cannot be taken; that is, we cannot take the address of a basic block which serves as the entry point to a function. So, we use the alternative IR:</p>

<div class="highlight highlight-source-assembly"><pre><span class="pl-k">call</span><span class="pl-en"> void @__note_taken(i8</span><span class="pl-s1">*</span><span class="pl-en"> bitcast (i32 ()</span><span class="pl-s1">*</span><span class="pl-en"> @main to i8</span><span class="pl-s1">*</span><span class="pl-en">)</span><span class="pl-s1">,</span><span class="pl-en"> i8</span><span class="pl-s1">*</span><span class="pl-en"> blockaddress(@main</span><span class="pl-s1">,</span><span class="pl-en"> %</span><span class="pl-c1">3</span><span class="pl-en">))</span></pre></div>

<p>Here, we take the address of main (and thus of the entry basic block), and cast it to a <code>void *</code> to be used as the argument to <code>__note_taken()</code>.</p>

<p>Internally, <code>__note_taken()</code> simply inserts the source and target addresses into an <code>unordered_map&lt;uintptr_t, unordered_set&lt;uintptr_t&gt;&gt;</code> data structure. In order to output the results, we use <a href="https://github.com/nlohmann/json">this json library</a> to convert this data structure intuitively into json:</p>

<p><a href="https://asciinema.org/a/dcilkxl32doq04axpfevf3cbl"><img src="https://asciinema.org/a/dcilkxl32doq04axpfevf3cbl.png" alt="asciicast"></a></p>

<h1>
<a id="applications" class="anchor" href="#applications" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Applications</h1>

<h2>
<a id="branch-coverage" class="anchor" href="#branch-coverage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Branch Coverage</h2>

<p>Once we have constructed the dynamically computed CFG, we can "diff" this against a more complete, statically computed control flow graph in order to determine which branches were not taken at runtime.</p>

<h2>
<a id="static-analysis-aide" class="anchor" href="#static-analysis-aide" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Static Analysis Aide</h2>

<p>Sometimes certain static analysis tools like IDA and radare2 will miss certain dynamic control flow instructions (<code>[call|jmp] rax</code>) as they are computationally hard to determine statically. Examples of these include switch-case statements and jump tables. Given a "good" execution of a program, we can likely reconstruct a good portion of the switch-case statement very simply.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/toshipiazza">toshipiazza</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
